import { promises as fs } from "fs";
import crypto from "crypto";
import path from "path";
import type {
  VirusTotalResponse,
  MalwareScanResult,
  DailyQuota,
} from "@/types";

class MalwareScanner {
  private apiKey: string | null;
  private dailyLimit = 500; // VirusTotal free API limit
  private quotaFile = path.join(process.cwd(), "data", "virustotal-quota.json");
  private cacheFile = path.join(process.cwd(), "data", "scan-cache.json");
  private suspiciousExtensions = [
    ".exe",
    ".bat",
    ".cmd",
    ".scr",
    ".pif",
    ".com",
    ".vbs",
    ".js",
    ".jar",
    ".msi",
    ".dll",
    ".ps1",
    ".sh",
    ".php",
    ".asp",
    ".jsp",
  ];
  private dangerousPatterns = [
    /eval\(/gi,
    /document\.write/gi,
    /window\.location/gi,
    /iframe\s+src/gi,
    /<script/gi,
    /javascript:/gi,
    /vbscript:/gi,
    /onload\s*=/gi,
    /onerror\s*=/gi,
    /onclick\s*=/gi,
  ];

  constructor() {
    this.apiKey = process.env.VIRUSTOTAL_API_KEY || null;
    this.ensureDataDirectory();
  }

  private async ensureDataDirectory() {
    const dataDir = path.join(process.cwd(), "data");
    try {
      await fs.access(dataDir);
    } catch {
      await fs.mkdir(dataDir, { recursive: true });
    }
  }

  private async getDailyQuota(): Promise<DailyQuota> {
    const today = new Date().toISOString().split("T")[0];

    try {
      const quotaData = await fs.readFile(this.quotaFile, "utf-8");
      const quota: DailyQuota = JSON.parse(quotaData);

      // Reset quota if it's a new day
      if (quota.date !== today) {
        return { date: today, used: 0, limit: this.dailyLimit };
      }

      return quota;
    } catch {
      // File doesn't exist or is corrupted
      return { date: today, used: 0, limit: this.dailyLimit };
    }
  }
  private async updateQuota(used: number) {
    const today = new Date().toISOString().split("T")[0];
    const quota: DailyQuota = { date: today, used, limit: this.dailyLimit };

    try {
      await fs.writeFile(this.quotaFile, JSON.stringify(quota, null, 2));
    } catch {
      // Silently fail if we can't update quota
    }
  }
  private async getFromCache(
    fileHash: string
  ): Promise<MalwareScanResult | null> {
    try {
      const cacheData = await fs.readFile(this.cacheFile, "utf-8");
      const cache = JSON.parse(cacheData);

      if (cache[fileHash]) {
        const cached = cache[fileHash];
        // Cache valid for 7 days
        const cacheAge = Date.now() - new Date(cached.scannedAt).getTime();
        if (cacheAge < 7 * 24 * 60 * 60 * 1000) {
          return {
            ...cached,
            source: "cache",
            scannedAt: new Date(cached.scannedAt),
          };
        }
      }
    } catch {
      // Cache file doesn't exist or is corrupted
    }

    return null;
  }
  private async saveToCache(fileHash: string, result: MalwareScanResult) {
    try {
      let cache: Record<string, MalwareScanResult> = {};
      try {
        const cacheData = await fs.readFile(this.cacheFile, "utf-8");
        cache = JSON.parse(cacheData);
      } catch {
        // Cache file doesn't exist, start fresh
      }
      cache[fileHash] = result;
      await fs.writeFile(this.cacheFile, JSON.stringify(cache, null, 2));
    } catch {
      // Failed to save to cache - continue without caching
    }
  }

  private async calculateFileHash(filePath: string): Promise<string> {
    const fileBuffer = await fs.readFile(filePath);
    return crypto.createHash("sha256").update(fileBuffer).digest("hex");
  }

  private async localScan(filePath: string): Promise<MalwareScanResult> {
    try {
      const fileContent = await fs.readFile(filePath, "utf-8");
      const fileExt = path.extname(filePath).toLowerCase();

      let isSuspicious = false;
      let isMalicious = false;
      let threatName = "";

      // Check file extension
      if (this.suspiciousExtensions.includes(fileExt)) {
        isSuspicious = true;
      }

      // Check for dangerous patterns in text files
      for (const pattern of this.dangerousPatterns) {
        if (pattern.test(fileContent)) {
          isSuspicious = true;
          if (
            pattern.source.includes("script") ||
            pattern.source.includes("eval")
          ) {
            isMalicious = true;
            threatName = "Potentially malicious script detected";
          }
        }
      }

      // Simple heuristic checks
      if (fileContent.includes("malware") || fileContent.includes("virus")) {
        isSuspicious = true;
      }

      return {
        isClean: !isSuspicious && !isMalicious,
        isSuspicious,
        isMalicious,
        threatName: threatName || undefined,
        source: "local",
        scannedAt: new Date(),
      };
    } catch {
      // If we can't read the file as text, do basic extension check
      const fileExt = path.extname(filePath).toLowerCase();
      const isSuspicious = this.suspiciousExtensions.includes(fileExt);

      return {
        isClean: !isSuspicious,
        isSuspicious,
        isMalicious: false,
        source: "local",
        scannedAt: new Date(),
      };
    }
  }

  private async virusTotalScan(
    filePath: string
  ): Promise<MalwareScanResult | null> {
    if (!this.apiKey) {
      return null;
    }
    const quota = await this.getDailyQuota();
    if (quota.used >= quota.limit) {
      // VirusTotal daily quota exceeded
      return null;
    }

    try {
      const fileHash = await this.calculateFileHash(filePath);

      // Check cache first
      const cached = await this.getFromCache(fileHash);
      if (cached) {
        return cached;
      }

      const fileBuffer = await fs.readFile(filePath);
      const formData = new FormData();
      formData.append("file", new Blob([fileBuffer]), path.basename(filePath));

      // Upload file for scanning
      const uploadResponse = await fetch(
        "https://www.virustotal.com/api/v3/files",
        {
          method: "POST",
          headers: {
            "x-apikey": this.apiKey,
          },
          body: formData,
        }
      );

      if (!uploadResponse.ok) {
        throw new Error(`Upload failed: ${uploadResponse.statusText}`);
      }

      const uploadResult = await uploadResponse.json();
      const analysisId = uploadResult.data.id;

      // Wait a bit for analysis to complete
      await new Promise((resolve) => setTimeout(resolve, 15000));

      // Get analysis results
      const analysisResponse = await fetch(
        `https://www.virustotal.com/api/v3/analyses/${analysisId}`,
        {
          headers: {
            "x-apikey": this.apiKey,
          },
        }
      );

      if (!analysisResponse.ok) {
        throw new Error(
          `Analysis fetch failed: ${analysisResponse.statusText}`
        );
      }
      const analysisResult: VirusTotalResponse = await analysisResponse.json();
      const stats = analysisResult.data.attributes.stats;
      const engines = analysisResult.data.attributes.last_analysis_results;

      // Update quota
      await this.updateQuota(quota.used + 1);

      const isMalicious = stats.malicious > 0;
      const isSuspicious = stats.suspicious > 0 || stats.malicious > 0;
      const isClean = stats.malicious === 0 && stats.suspicious === 0;

      let threatName = "";
      const engineResults: Array<{
        engine: string;
        result: string;
        category: string;
      }> = [];
      // Safety check for engines object
      if (engines && typeof engines === "object") {
        Object.entries(engines).forEach(([engineName, result]) => {
          if (result.result && result.result !== "clean") {
            engineResults.push({
              engine: engineName,
              result: result.result,
              category: result.category,
            });

            if (result.category === "malicious" && !threatName) {
              threatName = result.result;
            }
          }
        });
      }
      const scanResult: MalwareScanResult = {
        isClean,
        isSuspicious,
        isMalicious,
        threatName: threatName || undefined,
        engineResults,
        source: "virustotal",
        scannedAt: new Date(),
      };

      // Save to cache
      await this.saveToCache(fileHash, scanResult);

      return scanResult;
    } catch {
      // VirusTotal scan failed
      return null;
    }
  }

  async scanFile(filePath: string): Promise<MalwareScanResult> {
    try {
      // Always do local scan first
      const localResult = await this.localScan(filePath);

      // If local scan finds something suspicious or malicious, try VirusTotal for confirmation
      if (
        (localResult.isSuspicious || localResult.isMalicious) &&
        this.apiKey
      ) {
        const vtResult = await this.virusTotalScan(filePath);
        if (vtResult) {
          // Combine results - VirusTotal takes precedence for final verdict
          return {
            ...vtResult,
            source: "virustotal",
          };
        }
      }

      // For clean files, occasionally use VirusTotal for verification (random 10% of clean files)
      if (localResult.isClean && this.apiKey && Math.random() < 0.1) {
        const vtResult = await this.virusTotalScan(filePath);
        if (vtResult) {
          return vtResult;
        }
      }

      return localResult;
    } catch {
      // File scan failed
      return {
        isClean: false,
        isSuspicious: true,
        isMalicious: false,
        threatName: "Scan failed - file may be corrupted",
        source: "local",
        scannedAt: new Date(),
      };
    }
  }

  async getQuotaStatus(): Promise<{
    used: number;
    remaining: number;
    total: number;
    resetsAt: string;
  }> {
    const quota = await this.getDailyQuota();
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);

    return {
      used: quota.used,
      remaining: quota.limit - quota.used,
      total: quota.limit,
      resetsAt: tomorrow.toISOString(),
    };
  }
  async clearCache(): Promise<void> {
    try {
      await fs.unlink(this.cacheFile);
    } catch {
      // Cache file doesn't exist, which is fine
    }
  }

  isConfigured(): boolean {
    return this.apiKey !== null;
  }
}

export default MalwareScanner;
export type { MalwareScanResult };
